<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Detected Words</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @font-face {
            font-family: 'Alte Haas';
            src: url('Hershey-Noailles-Futura-Simplex-Bold.ttf') format('truetype');
        }

        @font-face {
            font-family: 'Alte Haas Bold';
            src: url('AlteHaasGroteskBold.ttf') format('truetype');
        }

        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        body {
            font-family: 'Alte Haas', sans-serif;
            text-transform: uppercase;
            text-align: center;
            background-color: #f5f5f5;
        }

        h1 {
            font-family: 'Alte Haas', sans-serif;
            margin: 20px 0;
            font-size: 45px;
            color: #000000;
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        canvas {
            display: block;
            margin: 0;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <h1 style="pointer-events: none;">SEEING BEING SEEN</h1>
    <script>
        // Matter.js 모듈 가져오기
        const { Engine, Render, Runner, Bodies, World, Composite, Mouse, MouseConstraint } = Matter;
    
        // Matter.js 엔진 생성
        const engine = Engine.create();
        engine.world.gravity.y = 1.2;
        engine.world.gravity.x = 0;
        engine.world.gravity.y = 1.2; // 중력 강도 조정 (기본값보다 약간 높게 설정)
    
        const world = engine.world;

        // 엔진 충돌 감지 품질 향상 설정
        engine.constraintIterations = 12;
        engine.positionIterations = 12;
    
        // 캔버스 렌더링 설정 (화면 크기 기반)
        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth, // 화면 전체 너비
                height: window.innerHeight, // 화면 전체 높이
                wireframes: false, // 사실적인 렌더링
                background: '#ffffff' // 배경 색상
            }
        });
        Render.run(render);
    
        // 러너 생성 및 설정 (시간 단계 조정)
        const runner = Runner.create();
        runner.isFixed = true;
        runner.delta = 1000 / 60; // 프레임 속도를 60FPS로 설정
        Runner.run(runner, engine);
    
        // 바닥 생성 (두께 증가)
        const ground = Bodies.rectangle(window.innerWidth / 2, window.innerHeight - 15, window.innerWidth, 50, {
            isStatic: true,
            label: "",
            restitution: 0.2,
            friction: 0.9,
            render: {
                visible: true, // 바닥을 보이게 설정하여 충돌 확인 가능
                fillStyle: '#ffffff' // 바닥 색상 설정
            }
        });
        World.add(world, ground);
        Matter.Body.setStatic(ground, true);
    
        // 좌우 경계 벽 생성
        const leftWall = Bodies.rectangle(0, window.innerHeight / 2, 30, window.innerHeight, {
            isStatic: true,
            label: "",
            render: {
                visible: false
            }
        });
    
        const rightWall = Bodies.rectangle(window.innerWidth, window.innerHeight / 2, 30, window.innerHeight, {
            isStatic: true,
            label: "",
            render: {
                visible: false
            }
        });
    
        World.add(world, [leftWall, rightWall]);
    
        // 추적용 변수
        let wordCounts = {}; // 각 단어의 생성 횟수를 저장하는 객체
    
        // 단어 생성 함수
        function createWord(text, x, y) {
            const wordWidth = text.length * 30;
            const wordHeight = 100;
            let randomX = 30 + Math.random() * (window.innerWidth - 60);
            let adjustedY = -200; // 단어 생성 위치를 더 높은 곳으로 설정

            // 이미 생성된 단어와 겹치지 않도록 위치 조정 반복
            let maxAttempts = 10;
            let attempt = 0;
            while (attempt < maxAttempts) {
                const bodies = Composite.allBodies(engine.world);
                let overlap = bodies.some(body => {
                    if (!body.isStatic && body.label !== "") {
                        const distance = Math.sqrt(Math.pow(body.position.x - randomX, 2) + Math.pow(body.position.y - adjustedY, 2));
                        return distance < wordWidth * 4.0; // 단어 간 거리가 너무 가까운지 확인
                    }
                    return false;
                });

                if (!overlap) {
                    break; // 겹치지 않는 위치를 찾았으면 반복 종료
                }

                randomX = 30 + Math.random() * (window.innerWidth - 60);
                adjustedY -= 50; // 위치를 더 위로 조정
                attempt++;
            }

            const wordBody = Bodies.rectangle(randomX, adjustedY, wordWidth, wordHeight, {
                density: 0.1,
                friction: 0.8, // 마찰력을 조정하여 단어들이 잘 미끄러지지 않도록 함
                restitution: 0.05, // 탄성 계수 증가
                render: {
                    fillStyle: '#ffffff',
                },
            });
            wordBody.label = text;
            World.add(world, wordBody);
        }
    
        // Flask 서버에서 데이터 가져오기
        async function fetchData() {
            try {
                const response = await fetch('http://192.168.0.31:5000/data');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json(); // JSON 데이터로 변환
    
                // 새로운 데이터가 있는지 비교 및 추가
                data.forEach(word => {
                    if (!wordCounts[word]) {
                        wordCounts[word] = 0; // 처음 등장한 단어는 0으로 초기화
                    }
    
                    // 서버에서 받은 데이터의 단어가 현재 추적 중인 단어 수보다 많으면 추가 생성
                    if (wordCounts[word] < data.filter(w => w === word).length) {
                        const countToAdd = data.filter(w => w === word).length - wordCounts[word];
                        
                        // 단어를 추가로 생성
                        for (let i = 0; i < countToAdd; i++) {
                            const randomX = 30 + Math.random() * (window.innerWidth - 60); // 단어의 초기 위치 X (화면 안쪽에만 생성)
                            createWord(word, randomX, -200); // 더 높은 곳에서 단어 생성
                        }
                        
                        // 현재 단어 생성 횟수 갱신
                        wordCounts[word] += countToAdd;
                    }
                });
    
            } catch (error) {
                console.error('Error fetching data:', error); // 에러 메시지 출력
            }
        }
    
        // Matter.js 캔버스에 단어 표시 (회전을 반영)
        Matter.Events.on(render, 'afterRender', function () {
            const bodies = Composite.allBodies(engine.world);
            const context = render.context;
    
            bodies.forEach(body => {
                if (body.label && body.label !== "") { // body에 label이 있는 경우 텍스트로 렌더링 (빈 label 제외)
                    const pos = body.position;
                    const angle = body.angle; // body의 회전 각도 가져오기
    
                    context.save(); // 현재 상태 저장
                    context.translate(pos.x, pos.y); // body 위치로 이동
                    context.rotate(angle); // body 각도로 회전
    
                    // 텍스트 렌더링
                    context.font = 'bold 50px Alte Haas, Arial';
                    context.fillStyle = '#000';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(body.label.toUpperCase(), 0, 0); // 현재 위치에서 텍스트 렌더링
    
                    context.restore(); // 이전 상태 복원
                }
            });
        });
    
        // 마우스 상호작용 추가
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: {
                    visible: false
                }
            }
        });
        World.add(world, mouseConstraint);
    
        // 마우스가 캔버스 위에서 정상적으로 동작하도록 렌더와 연동
        render.mouse = mouse;
    
        // 창 크기 변경에 따라 캔버스 크기 및 단어 재조정
        window.addEventListener('resize', () => {
            render.canvas.width = window.innerWidth;
            render.canvas.height = window.innerHeight;
    
            // 바닥 위치 및 크기 재조정
            Matter.Body.setPosition(ground, { x: window.innerWidth / 2, y: window.innerHeight - 15 });
            Matter.Body.setVertices(ground, [
                { x: 0, y: window.innerHeight - 15 },
                { x: window.innerWidth, y: window.innerHeight - 15 },
                { x: window.innerWidth, y: window.innerHeight },
                { x: 0, y: window.innerHeight }
            ]);
    
            // 좌우 벽 위치 및 크기 재조정
            Matter.Body.setPosition(leftWall, { x: 0, y: window.innerHeight / 2 });
            Matter.Body.setVertices(leftWall, [
                { x: 0, y: 0 },
                { x: 30, y: 0 },
                { x: 30, y: window.innerHeight },
                { x: 0, y: window.innerHeight }
            ]);
    
            Matter.Body.setPosition(rightWall, { x: window.innerWidth, y: window.innerHeight / 2 });
            Matter.Body.setVertices(rightWall, [
                { x: window.innerWidth - 30, y: 0 },
                { x: window.innerWidth, y: 0 },
                { x: window.innerWidth, y: window.innerHeight },
                { x: window.innerWidth - 30, y: window.innerHeight }
            ]);
    
            // 모든 단어 객체를 다시 현재 창 크기에 맞도록 이동
$1bodies.forEach(body => {
                if (!body.isStatic && body.label !== "") {
                    // 창 크기가 줄어들 때 단어들을 화면 중앙으로 약간 더 이동
                    if (window.innerWidth < render.options.width || window.innerHeight < render.options.height) {
                        const offsetX = (window.innerWidth - render.options.width) / 4;
                        const offsetY = (window.innerHeight - render.options.height) / 4;
                        Matter.Body.setPosition(body, {
                            x: body.position.x + offsetX,
                            y: body.position.y + offsetY
                        });
                    }
                }
                if (!body.isStatic && body.label !== "") {
                    // 단어 객체가 화면 밖으로 나가지 않도록 위치를 조정
                    if (body.position.x > window.innerWidth) {
                        Matter.Body.setPosition(body, { x: window.innerWidth - 100, y: body.position.y });
                    } else if (body.position.x < 0) {
                        Matter.Body.setPosition(body, { x: 100, y: body.position.y });
                    }
                    if (body.position.y > window.innerHeight) {
                        Matter.Body.setPosition(body, { x: body.position.x, y: window.innerHeight - 100 });
                    }
                }
            });
        });
    
        // Viewport Bound 설정을 통해 화면 밖으로 나가는 것을 제한
        render.options.hasBounds = true;
        render.bounds = {
            min: { x: 0, y: 0 },
            max: { x: window.innerWidth, y: window.innerHeight }
        };
    
        // 1초마다 Flask 서버에서 단어 가져오기
        setInterval(fetchData, 1000);
    </script>
</body>
</html>
